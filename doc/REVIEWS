----------------------- REVIEW 1 ---------------------
The article reports on the experience of automating certain 
proofs in Agda using the proof-by-reflection technique, with 
the help of Agda's reflection mechanism.

It is very well written, with clear examples and 
an impeccable presentation. However, it is rather light in 
terms of contributions. I identified three minor contributions.

* The first minor contribution is to explain proof-by-reflection in the
  language Agda. The proof by reflection technique is well-known, but I
  have not seen any explanation of it in Agda.

* Another minor contribution is to explain Agda's reflection
  mechanism, up to now only documented in release notes and source
  code. A complete explanation of Agda's reflection mechanism could be
  very interesting, but the explanation in the paper is rather brief,
  and not self-contained. 

* The last minor contribution is to present a library that relieves
  the programmer of some bureaucracy that appears when using
  reflection. As the authors note, the implementation of the library
  is not groundbreaking.

In summary, I think it is a nice paper, but I'm not convinced the
contributions are enough and, for the sake of brevity, many
definitions are not given or explained, hindering its value as a
tutorial.  The case for the paper would be stronger, had it explained
Agda's reflection in more detail, relieving the reader from the need
to go into release notes, and had it explain (at least intuitively)
all the definitions used.

Detailed comments noted.

----------------------- REVIEW 2 ---------------------
This paper describes the use of Agda's reflection mechanism to help with proof
automation, and gives some simple examples, including proving evenness of
natural numbers and proving that a boolean formula is a tautology.

It seems that proof automation is important for a practical language with
dependent types, and Agda's reflection mechanism as described is likely to
help. However, this paper only really scratches the surface of what is possible
- existing (unpublished, as far as I'm aware) examples such as the Ring solver
go much further towards demonstrating its value.

The 'Evenness' example uses a lot of space for something pretty simple. An in
practice, the number won't necessarily be known. What if you know "Even x" and
need to prove "Even (x + 100)". Does it still work? Similarly for the tautology
example - what if there is an unknown formula which is nevertheless known to be
a tautology? It would be nice, therefore, to show how such proof obligations
come up in practice and how the reflection techniques described help. Without
this, it's not clear that the paper answers the given central question of
whether Agda's reflective capabilities are sufficient and practically usable.

In summary: there's some nice tutorial material here describing reflection and
its application, but I think there are some limitations which need to be
addressed before the paper can be accepted. In particular, the paper needs to
discuss how the Boolean tautology example could scale to an infinite type such
as Nat.

Minor comments sorted.

----------------------- REVIEW 3 ---------------------
Summary of the Content

This paper gives an overview of alternative methods of proving
propositions in Agda. Rather than proving a proposition directly by
dependent pattern matching, uniqueness of the record type without
fields and eta expansion of records can be exploited to partially
automate proofs (similar to tactics). This works by reducing an
expression to a record of unique Unit record leaves, which can be
inferred as an implicit argument by Agda.

The paper also briefly overviews Agda's reflection mechanism, and
shows how it can be used to automate the production of values in the
expression language representing the goal proposition (which are
passed as arguments to "tactics".) The paper contributes a novel
Autoquote mechanism that enables the translation from the expression
language to the propositional language to be specified declaratively.
Without Autquote, verbose boilerplate must be written to translate
quoted terms into an expression language that tactics operate on.

The Review

The paper does a good job of summarzing the current situation of
proofs by reflection in Agda, and motivates the need for Agda's
quoting facilities to get rid of duplicate information in the type of
the goal and arguments passed to tactics. The declarative Autoquote
translation table is a much needed alernative to supplying boilerplate
translations of quoted terms into expressions AST's.

In a way the translation table is an instance of a more general
mechanism to recover a notion of simple "pattern matching" from an abstract
datatype only exposing equality operations. In this case "names" are
the abstract datatype (ADT), which expose decidable equality functions that
make up the implementation of the declarative pattern matching-esque
table.

Maybe you could address why Agda does not support pattern matching on
names? Is this a technial or theoretical limitation? Agda does support
pattern matching on the infinitely inhabited String datatype, so it
seems like pattern matching on names could be supported in addition to
providing decidable equality functions.

The Evenness and Boolean Tautologies are illustrative of the problems
being addressed and the former is a good introductory version of the
latter. Essentially Evenness is a "closed" example with no quantified
variables, and Boolean Tautologies is an "open" example with
quantified variables. It would be helpful to include such a wording in
the section names, or explicitly mention the difference in the prose.

I assume that the first argument of a Table value is a special case.
It always specifies the constructor to be used for variables, while
the remaining table values are mappings from term names to
constructors. It would be more clear to point out this special case.

I was a bit dissapointed when learning at the very end that Autoquote
can only translate into non-dependent types. It would be better to set
expectations properly in the beginning of the paper. You could modify
the contributions list to say that Autoquote translates a quoted
expression to a non-dependent datatype AST that represents it.

Finally, in Boolean Tautologies the type of variables is a finite
enumeration (Bool). This allows the proof tree to enumerate all
possible ways the proposition in question could reduce. Does this
approach scale to infinite types like Nat? If not, the limitation
should be mentioned. If so, it should be pointed out and hopefully
reference a particular example to look at in detail in the provided
library code.

In summary, the paper contributes a useful declarative translation
table whose use is demonstrated by example. Overall the examples do a
good job of motivating the need for Autoquote, but the paper should
clarify the issues mentioned above.


----------------------- REVIEW 4 ---------------------
The paper is clear in its intention: to explore the practical use of the Agda
reflection API. It does this by means of two examples: showing that even
numbers are even, and that Boolean tautologies are indeed tautologies. The
examples are developed step-by-step, but it can be difficult to follow,
particularly in the latter example, without a clearer high-level statement at
the beginning of the example giving an indication about how it will be solved.

While the examples are interesting, I am tempted to ask what we might conclude
from it. While it's of clear value to the Agda implementors, it perhaps has the
message for the non-expert that using the system in practice is difficult. To
quote an example from p10 "The Diff argument is unfortunately needed for...

Detailed comments noted.
