----------------------- REVIEW 2 ---------------------

It seems that proof automation is important for a practical language with
dependent types, and Agda's reflection mechanism as described is likely to
help. However, this paper only really scratches the surface of what is possible
- existing (unpublished, as far as I'm aware) examples such as the Ring solver
go much further towards demonstrating its value.

The 'Evenness' example uses a lot of space for something pretty simple. And in
practice, the number won't necessarily be known. What if you know "Even x" and
need to prove "Even (x + 100)". Does it still work? Similarly for the tautology
example - what if there is an unknown formula which is nevertheless known to be
a tautology? It would be nice, therefore, to show how such proof obligations
come up in practice and how the reflection techniques described help. Without
this, it's not clear that the paper answers the given central question of
whether Agda's reflective capabilities are sufficient and practically usable.

In particular, the paper needs to
discuss how the Boolean tautology example could scale to an infinite type such
as Nat.

----------------------- REVIEW 3 ---------------------
Summary of the Content

This paper gives an overview of alternative methods of proving
propositions in Agda. Rather than proving a proposition directly by
dependent pattern matching, uniqueness of the record type without
fields and eta expansion of records can be exploited to partially
automate proofs (similar to tactics). This works by reducing an
expression to a record of unique Unit record leaves, which can be
inferred as an implicit argument by Agda.

The Review

Maybe you could address why Agda does not support pattern matching on
names? Is this a technial or theoretical limitation? Agda does support
pattern matching on the infinitely inhabited String datatype, so it
seems like pattern matching on names could be supported in addition to
providing decidable equality functions.

The Evenness and Boolean Tautologies are illustrative of the problems
being addressed and the former is a good introductory version of the
latter. Essentially Evenness is a "closed" example with no quantified
variables, and Boolean Tautologies is an "open" example with
quantified variables. It would be helpful to include such a wording in
the section names, or explicitly mention the difference in the prose.

Finally, in Boolean Tautologies the type of variables is a finite
enumeration (Bool). This allows the proof tree to enumerate all
possible ways the proposition in question could reduce. Does this
approach scale to infinite types like Nat? If not, the limitation
should be mentioned. If so, it should be pointed out and hopefully
reference a particular example to look at in detail in the provided
library code.

----------------------- REVIEW 4 ---------------------
numbers are even, and that Boolean tautologies are indeed tautologies. The
examples are developed step-by-step, but it can be difficult to follow,
particularly in the latter example, without a clearer high-level statement at
the beginning of the example giving an indication about how it will be solved.

While the examples are interesting, I am tempted to ask what we might conclude
from it. While it's of clear value to the Agda implementors, it perhaps has the
message for the non-expert that using the system in practice is difficult. To
quote an example from p10 "The Diff argument is unfortunately needed for...
