\section{Introduction}

The aim of this project is to explore the new (since version 2.2.8) reflection API included in the Agda
compiler, and come up with a number of novel examples of its applications. Reflection in programming language
terms means that one can convert concrete syntax of the language (terms and expressions, etc.) into an abstract
representation (usually some abstract syntax tree; this process is often referred to as ``quoting'')
which can be traversed, inspected and modified using the same programming
language. Usually (but not always) languages supporting reflection have the possibility to
``unquote'' again, effectively
converting the abstract representation of the expression back into concrete syntax. Using this technique is often referred to as meta programming,
since one is programming with programs: one can alter behaviour
or instantiate specific functionality (possibly from a more general template) at run- or compile-time.

The main question which we aim to answer during this project is:

``Given the new reflection API in Agda, what interesting applications can we give
examples of? Which tedious and mundane tasks can we automate? What advantages does
Agda's implementation of reflection have over other languages which already have reflection?
\footnote{Notably LISP and Template Haskell already have mature and fully featured reflective systems.}''

This technique provides many interesting possibilities for easing a programmer's life, and in
this project a number of illustrative
examples are presented on how one can effectively use reflection.
This immediately brings us to the contributions of this work:

\begin{itemize}
  \item First, possibly the most useful contribution -- but least
interesting academically -- is a user-friendly manual to using the
Reflection API. The Agda release notes\cite{agda-relnotes-228} do
include a short summary of the data types and functions involved, but
in practice it takes quite some frustrating hours to familiarise
oneself with the way the AST is put together. This thesis contains a
section on using the reflection API, along with a few simple,
practical examples, and a few tips and tricks for effectively
converting between the Agda Term type and your own (possibly
restrictive, property-ensuring) AST. See Sec. \ref{sec:refl-docu}.
  \item The proof technique suggestively called proof by reflection
can benefit from using reflection in the programming language
sense. The idea here is that instead of producing a specific proof
derivation tree for each specific instance (some true statement which
can be produced using the rules), one defines an algorithm that computes a proof object for every given problem instance. This is easily illustrated
with properties such as the evenness of natural numbers, or the fact
that certain boolean expressions are tautologies. Proof by reflection,
plus the advantages of using reflection, are laid out here, including
an example implementation. See Sec. \ref{sec:proof-by-reflection}.
  \item Another example is allowing untyped STLC (simply typed lambda
calculus) terms to be quoted, type- and scope-checked, and then
automatically converted to SKI-combinators or CPS (continuation
passing style) transformed. This is both an illustration of the powers of
dependently typed programming -- one can define a data type such
that only well-typed, well-scoped lambda terms can be expressed, and the
powerful type system allows calculation of the quoted term's type, so the transformation
is type-safe -- as a
nice example of what can be done with a powerful reflection mechanism. Most
readers will be familiar with a similar idea using Template Haskell, except that
the problem there is that the entire reflection system is untyped, which often
means debugging type errors in the generated code. The type-safe approach presented
here, which is only possible using dependent types, largely relegates these problems
to the past tense. See Sec. \ref{sec:type-safe-metaprogramming}.
  \item Generic programming is another technique which stands to
benefit from good reflective capabilities. Even though using an
intermediate generic representation type for data types allows the
definition of generic functions that aid reuse of code, often
embedding-projection functions still need to be defined between this
representation type and all the instances of data types one wants to be
able to support. If one only needs to pass the
(quoted) data type definition to a function which generates an EP-pair
of functions which can be unquoted, this process could be completely
automated. Often defining such EP-pairs is a rather mechanical and
tedious process anyway.
  \item Certain design patterns can be abstracted away using
reflection. Take the Bove-Capretta method as an example, where
non-terminating functions (at least, those that do terminate but that
don't pass the termination checker because of a complex recursion
structure) can be rewritten to include an auxiliary argument which
decreases structurally on each recursive call; this modification can be done at compile-time, so the programmer doesn't
need to do the rewriting manually, only the proof obligation that
would otherwise be
the result of the BC method would need to be given.  This is in fact
edging towards a framework for defining tactics, such as is
commonplace in other proof assistants such as Coq, since the
compiler is rewriting the function at compile-time and one doesn't
need to manually rewrite functions or have large derivation trees
explicitly written out in your code base.  In fact, we think this is
an interesting avenue to pursue, since one of the larger obstacles to
using Agda for life-sized projects is the often cumbersome and tedious
proofs that need to be done manually or by combining properties from
the standard library instead of just discharging them by calling a
tactic.
%  \item Finally, a few minor modifications to the Agda code base were
%introduced during this project which make an Agda programmer's life
%slightly less painful, such as the automatic expansion of a
%with-clause, and the generation of an in-scope-symbols list which is
%useful for automatic formatting and colouring of Literate Agda using
%the LHS2\TeX\ system developed by Andres L\"oh, and widely used by the
%Haskell and Agda community for laying out and formatting Haskell and
%Agda code in articles and presentations.
\end{itemize}



